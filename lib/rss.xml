<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[cp1]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib/media/favicon.png</url><title>cp1</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Sun, 14 Apr 2024 05:58:32 GMT</lastBuildDate><atom:link href="lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Sun, 14 Apr 2024 05:58:30 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[index]]></title><description><![CDATA[ 
 <br><br><br>Edges are characterized by a rapid variation in the intensity of the pixels. Fig.1 represents the brightness profile along a horizontal blue line in image, which clearly shows a sudden decrease in the brightness of the pixels.<br><img alt="pics/edge_intensity.png" src="pics/edge_intensity.png"><br>with following implementation<br>import skimage.io as io
import skimage.color as color
import matplotlib
matplotlib.use("TkAgg")
import matplotlib.pyplot as plt

def convert_to_rgb_format(img):
    if img.shape[2] == 4:
        img = color.rgba2rgb(img)
    return img


def convert_to_gray_scale(img):
    return color.rgb2gray(img)

img = io.imread("./sky.png")

img = convert_to_rgb_format(img)

g = convert_to_gray_scale(img)

cut = 600
profil = g[cut, :]

plt.figure(figsize=(10, 5)) 

plt.subplot(1, 2, 1)  
plt.plot(profil, "b")  
plt.title("Brightness profile")  

plt.subplot(1, 2, 2) 
plt.imshow(g, cmap="gray")  
plt.plot((0, g.shape[1]), (cut, cut), "b")  
plt.title("City")  

plt.show()


Copy<br><br><br>an edge can be detected by analyzing the first derivative of the intensity profile, taken perpendicular to the edge. Similarly, an edge can be detected by determining the zero crossing of the second derivative.<br><br>and gradient with finite differences<br><br>and second order derivative, Laplacian<br><br>this is the illustration of application of first and second order derivatives with forward difference<br><img alt="pics/bright_der.png" src="pics/bright_der.png"><br>with  implementation<br>import numpy as np
import skimage.io as io
import skimage.color as color
import matplotlib

matplotlib.use("TkAgg")
import matplotlib.pyplot as plt


def convert_to_rgb_format(img):
    if img.shape[2] == 4:
        img = color.rgba2rgb(img)
    return img


def convert_to_gray_scale(img):
    return color.rgb2gray(img)


def grad_f(y):
    grd = [0 for _ in range(y.shape[0])]
    for i in range(y.shape[0] - 1):
        grd[i] = y[i + 1] - y[i]
    return np.array(grd)


img = io.imread("./sky.png")

img = convert_to_rgb_format(img)

g = convert_to_gray_scale(img)

cut = 600
profil = g[cut, :]

y = np.array(profil)

grd = grad_f(y)

grd_2 = grad_f(grd)

fig, axs = plt.subplots(1, 3, figsize=(15, 5))


axs[0].plot(y, color="blue")
axs[0].set_title("initial brigtness intensity")


axs[1].plot(grd, color="blue")
axs[1].set_title("first order derivative")


axs[2].plot(grd_2, color="blue")
axs[2].set_title("second order derivative")

plt.tight_layout()
plt.show()

Copy<br><br>to investigate impact of truncation errors we can calculate gradient and Laplacian for multiple finite differences formulas compare results by visualizing and calculate relative errors<br><br><br><br><br><br>from the image below we can see that central difference yields more accurate rate of change in intensity of pixels from initial picture. <br><img alt="pics/diff_types.png" src="pics/diff_types.png"><br>with relative errors<br>Relative error between forward and backward 6.167518521609531
Relative error between forward and central 3.0837592608047655
Relative error between backward and central 3.0837592608047655
Copy<br>and implementation<br>import numpy as np
import skimage.io as io
import skimage.color as color
import matplotlib
matplotlib.use("TkAgg")
import matplotlib.pyplot as plt

def convert_to_rgb_format(img):
    if img.shape[2] == 4:
        img = color.rgba2rgb(img)
    return img


def convert_to_gray_scale(img):
    return color.rgb2gray(img)


def forward_f(y):
    grd = [0 for _ in range(y.shape[0])]
    for i in range(y.shape[0] - 1):
        grd[i] = y[i + 1] - y[i]
    return np.array(grd)


def backward_f(y):
    grd = [0 for _ in range(y.shape[0])]
    for i in range(1, y.shape[0]):
        grd[i] = y[i] - y[i - 1]
    return np.array(grd)


def central_f(y):
    grd = [0 for _ in range(y.shape[0])]
    for i in range(1, y.shape[0] - 1):
        grd[i] = (y[i + 1] - y[i - 1]) / 2
    return np.array(grd)


def relative_error(x, y):
    return np.linalg.norm(x - y)

img = io.imread("./sky.png")

img = convert_to_rgb_format(img)

g = convert_to_gray_scale(img)

cut = 600
profil = g[cut, :]

y = np.array(profil)

f_y = forward_f(y)
b_y = backward_f(y)
c_y = central_f(y)

print(f"Relative error between forward and backward {relative_error(f_y,b_y)}")
print(f"Relative error between forward and central {relative_error(f_y,c_y)}")
print(f"Relative error between backward and central {relative_error(b_y,c_y)}")

fig, axs = plt.subplots(1, 3, figsize=(15, 5))

axs[0].plot(f_y, color="blue")
axs[0].set_title("forward difference")


axs[1].plot(b_y, color="blue")
axs[1].set_title("backward difference")


axs[2].plot(c_y, color="blue")
axs[2].set_title("central difference")

plt.tight_layout()
plt.show()
Copy<br><a data-href="Problem 2.2" href="problem-2.2.html" class="internal-link" target="_self" rel="noopener">Problem 2.2</a>]]></description><link>index.html</link><guid isPermaLink="false">index.md</guid><dc:creator><![CDATA[john doe -_-]]></dc:creator><pubDate>Sat, 13 Apr 2024 19:27:46 GMT</pubDate><enclosure url="pics/edge_intensity.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="pics/edge_intensity.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Problem 2.2]]></title><description><![CDATA[ 
 <br><br>to investigate higher order derivatives we can use  Prewitt operators and compute convolution.<br>
for first order derivative it has following form<br><br>with kernel<br><br>and similar idea is applied to higher order derivatives with kernels<br><br>
<br>first calculate vertical and horizontal Prewitt operators by convolution
<br> <br> and then calculate magnitude M with is "fusion" of both operators to get the final result<br> <br> and to get even more clear image we can use Thresholding to get following result<br><img src="pics/edging.png"><br><br>we can even get additional information by calculating angle of the edge.<br>
by calculating following expression <br><br>the color of the edges corresponds to the angle. For example, an angle of 0 is re<a rel="noopener" class="external-link" href="" target="_blank"></a>d, and an angle of  is blue.<br><img src="pics/angle.png"><br>and following implementation<br>import numpy as np
import skimage.io as io
import skimage.color as color
import matplotlib
from scipy.signal import convolve

matplotlib.use("TkAgg")

import matplotlib.pyplot as plt


def convert_to_rgb_format(img):
    if img.shape[2] == 4:
        img = color.rgba2rgb(img)
    return img


def convert_to_gray_scale(img):
    return color.rgb2gray(img)


def threshold(g, T):
    h, w = g.shape[:2]
    for j in range(h):
        for i in range(w):
            if g[j, i] &gt;= T:
                g[j, i] = 1
            else:
                g[j, i] = 0
    return g


def prewitt_operator(g):
    h_x = np.array([[1, 0, -1], [1, 0, -1], [1, 0, -1]])
    h_y = np.array([[1, 1, 1], [0, 0, 0], [-1, -1, -1]])

    grad_x = convolve(g, h_x, mode="same")
    grad_y = convolve(g, h_y, mode="same")

    M = np.sqrt(grad_x**2 + grad_y**2)  # NOTE: magnitude M

    A = np.arctan(grad_y / grad_x)  # NOTE: angle A

    return M, A


img = io.imread("./sky.png")

img = convert_to_rgb_format(img)

g = convert_to_gray_scale(img)

M, A = prewitt_operator(g)

plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.imshow(img)
plt.title("Original Image")

plt.subplot(1, 2, 2)
plt.imshow(threshold(M, 0.5), cmap="gray")
plt.title("Prewitt Operator with magnitude M")
plt.show()
Copy<br><a data-href="Problem 2.3" href="problem-2.3.html" class="internal-link" target="_self" rel="noopener">Problem 2.3</a>]]></description><link>problem-2.2.html</link><guid isPermaLink="false">Problem 2.2.md</guid><pubDate>Sat, 13 Apr 2024 19:01:01 GMT</pubDate><enclosure url="pics/edging.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="pics/edging.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Problem 2.3]]></title><description><![CDATA[ 
 <br><a data-href="Problem 2.4" href="problem-2.4.html" class="internal-link" target="_self" rel="noopener">Problem 2.4</a>]]></description><link>problem-2.3.html</link><guid isPermaLink="false">Problem 2.3.md</guid><pubDate>Sat, 13 Apr 2024 19:01:14 GMT</pubDate></item><item><title><![CDATA[Problem 2.4]]></title><description><![CDATA[ 
 ]]></description><link>problem-2.4.html</link><guid isPermaLink="false">Problem 2.4.md</guid><pubDate>Sat, 13 Apr 2024 19:01:14 GMT</pubDate></item></channel></rss>